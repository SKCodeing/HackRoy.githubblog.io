{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"5cb6e08e295779f4b3418c1eb463c44dac183f7e","modified":1506668986000},{"_id":"source/404/index.md","hash":"20985a7a6a90ab30d4c373bf7f8d1e76955bc458","modified":1506668986000},{"_id":"source/_posts/hexo常用命令笔记.md","hash":"8aa5fd417e47eeb44e868fa5e019b7004ceb17ab","modified":1506668986000},{"_id":"source/_posts/精品文献合集.md","hash":"80b7e168f03b962029c6f10a4ff8c40461f73842","modified":1506668986000},{"_id":"source/about/index.md","hash":"a674f63ff75c8b0a2a19090bd9a105d21115a7b2","modified":1506668986000},{"_id":"source/_posts/注册、登录和token的安全之道.md","hash":"657cfed008d26ff6462e2a8ebf334afc2c2ae5a5","modified":1506668986000},{"_id":"source/categories/index.md","hash":"cb352d5a360da5499dc550fad94cf20321a79dd9","modified":1506668986000},{"_id":"source/iOS/index.md","hash":"a20f69b25da02087c4437fb376e04e71688bb9ec","modified":1506668986000},{"_id":"source/tags/index.md","hash":"f32f048b44a2b14ef63244b73f6ca392dc92fbf9","modified":1506668986000},{"_id":"public/404/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025167},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025167},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/2017/09/29/hexo常用命令笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/2017/09/28/精品文献合集/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/2017/09/28/注册、登录和token的安全之道/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/categories/PHP/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/Android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/Python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/PHP/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025168},{"_id":"public/tags/Interface/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506669025169},{"_id":"public/CNAME","hash":"5cb6e08e295779f4b3418c1eb463c44dac183f7e","modified":1506669025170}],"Category":[{"name":"PHP","_id":"cj85ju418000d5iutsnjao5sq"}],"Data":[],"Page":[{"title":"404","date":"2017-09-28T08:12:45.000Z","type":"commonweal","comments":0,"_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2017-09-28 16:12:45\ntype: \"commonweal\"\ncomments: false\n---\n","updated":"2017-09-29T07:09:46.000Z","path":"404/index.html","layout":"page","_id":"cj85ju40o00005iut3sccpeu5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About Me","date":"2017-09-18T06:32:54.000Z","_content":"> - 会点前端，写点后台，写过易语言，研究过文件系统，做过iOS安全，搞些越狱开发，学点Android。","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2017-09-18 14:32:54\n---\n> - 会点前端，写点后台，写过易语言，研究过文件系统，做过iOS安全，搞些越狱开发，学点Android。","updated":"2017-09-29T07:09:46.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj85ju40t00025iutbmje8i68","content":"<blockquote>\n<ul>\n<li>会点前端，写点后台，写过易语言，研究过文件系统，做过iOS安全，搞些越狱开发，学点Android。</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>会点前端，写点后台，写过易语言，研究过文件系统，做过iOS安全，搞些越狱开发，学点Android。</li>\n</ul>\n</blockquote>\n"},{"title":"分类","date":"2017-09-28T02:22:42.000Z","type":"categories","comments":0,"layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-09-28 10:22:42\ntype: \"categories\"\ncomments: false\nlayout: categories\n---\n","updated":"2017-09-29T07:09:46.000Z","path":"categories/index.html","_id":"cj85ju41g000j5iutnyz1wrj1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-09-28T08:06:39.000Z","type":"tags","comments":0,"layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-09-28 16:06:39\ntype: \"tags\"\ncomments: false\nlayout: tags\n---\n","updated":"2017-09-29T07:09:46.000Z","path":"tags/index.html","_id":"cj85ju41h000k5iutnksjo3zp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS","date":"2017-09-28T03:37:46.000Z","_content":"","source":"iOS/index.md","raw":"---\ntitle: iOS\ndate: 2017-09-28 11:37:46\n---\n","updated":"2017-09-29T07:09:46.000Z","path":"iOS/index.html","comments":1,"layout":"page","_id":"cj85ju41k000l5iute4kahymb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo常用命令笔记","date":"2017-09-29T02:01:28.000Z","_content":"\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n\n```\n\n> 简写\n\n```\nhexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\nhexo p == hexo publish\nhexo g == hexo generate#生成\nhexo s == hexo server #启动服务预览\nhexo d == hexo deploy#部署\n\n```\n> 服务器\n\n```\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n\nhexo clean #清除缓存 网页正常情况下可以忽略此条命令\nhexo g #生成静态网页\nhexo d #开始部署\n```\n> 监视文件变动\n\n```\nhexo generate #使用 Hexo 生成静态文件快速而且简单\nhexo generate --watch #监视文件变动\n```\n> 完成后部署\n\n```\n两个命令的作用是相同的\nhexo generate --deploy\nhexo deploy --generate\n```\n\n> 草稿\n\n```\nhexo publish [layout] <title>\n```\n\n> 模版\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n```\n\n> 推送到服务器上\n\n```\nhexo n #写文章\nhexo g #生成\nhexo d #部署 #可与hexo g合并为 hexo d -g\n```\n> 报错\n\n```\n1.找不到git部署\nERROR Deployer not found: git\n解决方法\n\nnpm install hexo-deployer-git --save\n\n2.部署类型设置git\nhexo 3.0 部署类型不再是github，_config.yml 中修改\n\n Deployment\n Docs: http://hexo.io/docs/deployment.html\n\ndeploy:\n  type: git\n  repository: git@***.github.com:***/***.github.io.git\n  branch: master\n\n3. xcodebuild\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n\nnpm install bcrypt\n\n4. RSS不显示\n安装RSS插件\n\nnpm install hexo-generator-feed --save\n```\n> 开启RSS功能编辑hexo/_config.yml，添加如下代码：\n\n```\nrss: /atom.xml #rss地址  默认即可\n```\n\n> 开启评论\n\n- 1.我使用多说代替自带的评论，在多说 网站注册 > 后台管理 > 添加新站点 > 工具 === 复制通用代码 里面有 short_name\n- 2.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的\n- 3.复制到 themes\\landscape\\layout\\_partial\\article.ejs\n- 4.把下面这段代码\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n<section id=\"comments\">\n<div id=\"disqus_thread\">\n  <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n</div>\n</section>\n<% } %>\n```\n改为\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n  <section id=\"comments\">\n    <!-- 多说评论框 start -->\n    <div class=\"ds-thread\" data-thread-key=\"<%= post.layout %>-<%= post.slug %>\" data-title=\"<%= post.title %>\" data-url=\"<%= page.permalink %>\"></div>\n    <!-- 多说评论框 end -->\n    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n    <script type=\"text/javascript\">\n    var duoshuoQuery = {short_name:'<%= config.disqus_shortname %>'};\n      (function() {\n        var ds = document.createElement('script');\n        ds.type = 'text/javascript';ds.async = true;\n        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n        ds.charset = 'UTF-8';\n        (document.getElementsByTagName('head')[0] \n         || document.getElementsByTagName('body')[0]).appendChild(ds);\n      })();\n      </script>\n    <!-- 多说公共JS代码 end -->\n  </section>\n<% } %>\n```","source":"_posts/hexo常用命令笔记.md","raw":"---\ntitle: Hexo常用命令笔记\ndate: 2017-09-29 10:01:28\ntags: hexo\n---\n\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n\n```\n\n> 简写\n\n```\nhexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\nhexo p == hexo publish\nhexo g == hexo generate#生成\nhexo s == hexo server #启动服务预览\nhexo d == hexo deploy#部署\n\n```\n> 服务器\n\n```\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n\nhexo clean #清除缓存 网页正常情况下可以忽略此条命令\nhexo g #生成静态网页\nhexo d #开始部署\n```\n> 监视文件变动\n\n```\nhexo generate #使用 Hexo 生成静态文件快速而且简单\nhexo generate --watch #监视文件变动\n```\n> 完成后部署\n\n```\n两个命令的作用是相同的\nhexo generate --deploy\nhexo deploy --generate\n```\n\n> 草稿\n\n```\nhexo publish [layout] <title>\n```\n\n> 模版\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n```\n\n> 推送到服务器上\n\n```\nhexo n #写文章\nhexo g #生成\nhexo d #部署 #可与hexo g合并为 hexo d -g\n```\n> 报错\n\n```\n1.找不到git部署\nERROR Deployer not found: git\n解决方法\n\nnpm install hexo-deployer-git --save\n\n2.部署类型设置git\nhexo 3.0 部署类型不再是github，_config.yml 中修改\n\n Deployment\n Docs: http://hexo.io/docs/deployment.html\n\ndeploy:\n  type: git\n  repository: git@***.github.com:***/***.github.io.git\n  branch: master\n\n3. xcodebuild\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n\nnpm install bcrypt\n\n4. RSS不显示\n安装RSS插件\n\nnpm install hexo-generator-feed --save\n```\n> 开启RSS功能编辑hexo/_config.yml，添加如下代码：\n\n```\nrss: /atom.xml #rss地址  默认即可\n```\n\n> 开启评论\n\n- 1.我使用多说代替自带的评论，在多说 网站注册 > 后台管理 > 添加新站点 > 工具 === 复制通用代码 里面有 short_name\n- 2.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的\n- 3.复制到 themes\\landscape\\layout\\_partial\\article.ejs\n- 4.把下面这段代码\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n<section id=\"comments\">\n<div id=\"disqus_thread\">\n  <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n</div>\n</section>\n<% } %>\n```\n改为\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n  <section id=\"comments\">\n    <!-- 多说评论框 start -->\n    <div class=\"ds-thread\" data-thread-key=\"<%= post.layout %>-<%= post.slug %>\" data-title=\"<%= post.title %>\" data-url=\"<%= page.permalink %>\"></div>\n    <!-- 多说评论框 end -->\n    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n    <script type=\"text/javascript\">\n    var duoshuoQuery = {short_name:'<%= config.disqus_shortname %>'};\n      (function() {\n        var ds = document.createElement('script');\n        ds.type = 'text/javascript';ds.async = true;\n        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n        ds.charset = 'UTF-8';\n        (document.getElementsByTagName('head')[0] \n         || document.getElementsByTagName('body')[0]).appendChild(ds);\n      })();\n      </script>\n    <!-- 多说公共JS代码 end -->\n  </section>\n<% } %>\n```","slug":"hexo常用命令笔记","published":1,"updated":"2017-09-29T07:09:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj85ju40p00015iut34gkrn6l","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo -g #安装  </div><div class=\"line\">npm update hexo -g #升级  </div><div class=\"line\">hexo init #初始化</div></pre></td></tr></table></figure>\n<blockquote>\n<p>简写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</div><div class=\"line\">hexo p == hexo publish</div><div class=\"line\">hexo g == hexo generate#生成</div><div class=\"line\">hexo s == hexo server #启动服务预览</div><div class=\"line\">hexo d == hexo deploy#部署</div></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</div><div class=\"line\">hexo server -s #静态模式</div><div class=\"line\">hexo server -p 5000 #更改端口</div><div class=\"line\">hexo server -i 192.168.1.1 #自定义 IP</div><div class=\"line\"></div><div class=\"line\">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</div><div class=\"line\">hexo g #生成静态网页</div><div class=\"line\">hexo d #开始部署</div></pre></td></tr></table></figure>\n<blockquote>\n<p>监视文件变动</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate #使用 Hexo 生成静态文件快速而且简单</div><div class=\"line\">hexo generate --watch #监视文件变动</div></pre></td></tr></table></figure>\n<blockquote>\n<p>完成后部署</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">两个命令的作用是相同的</div><div class=\"line\">hexo generate --deploy</div><div class=\"line\">hexo deploy --generate</div></pre></td></tr></table></figure>\n<blockquote>\n<p>草稿</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo publish [layout] &lt;title&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>模版</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div><div class=\"line\">hexo generate #生成静态页面至public目录</div><div class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\">hexo deploy #将.deploy目录部署到GitHub</div><div class=\"line\"></div><div class=\"line\">hexo new [layout] &lt;title&gt;</div><div class=\"line\">hexo new photo &quot;My Gallery&quot;</div><div class=\"line\">hexo new &quot;Hello World&quot; --lang tw</div></pre></td></tr></table></figure>\n<blockquote>\n<p>推送到服务器上</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n #写文章</div><div class=\"line\">hexo g #生成</div><div class=\"line\">hexo d #部署 #可与hexo g合并为 hexo d -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>报错</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.找不到git部署</div><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\">解决方法</div><div class=\"line\"></div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"></div><div class=\"line\">2.部署类型设置git</div><div class=\"line\">hexo 3.0 部署类型不再是github，_config.yml 中修改</div><div class=\"line\"></div><div class=\"line\"> Deployment</div><div class=\"line\"> Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\"></div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@***.github.com:***/***.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"></div><div class=\"line\">3. xcodebuild</div><div class=\"line\">xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance</div><div class=\"line\"></div><div class=\"line\">npm install bcrypt</div><div class=\"line\"></div><div class=\"line\">4. RSS不显示</div><div class=\"line\">安装RSS插件</div><div class=\"line\"></div><div class=\"line\">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>\n<blockquote>\n<p>开启RSS功能编辑hexo/_config.yml，添加如下代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rss: /atom.xml #rss地址  默认即可</div></pre></td></tr></table></figure>\n<blockquote>\n<p>开启评论</p>\n</blockquote>\n<ul>\n<li>1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</li>\n<li>2.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</li>\n<li>3.复制到 themes\\landscape\\layout_partial\\article.ejs</li>\n<li>4.把下面这段代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">&lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">&lt;div id=&quot;disqus_thread&quot;&gt;</div><div class=\"line\">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">  &lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">    &lt;!-- 多说评论框 start --&gt;</div><div class=\"line\">    &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;</div><div class=\"line\">    &lt;!-- 多说评论框 end --&gt;</div><div class=\"line\">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</div><div class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;;</div><div class=\"line\">      (function() &#123;</div><div class=\"line\">        var ds = document.createElement(&apos;script&apos;);</div><div class=\"line\">        ds.type = &apos;text/javascript&apos;;ds.async = true;</div><div class=\"line\">        ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;</div><div class=\"line\">        ds.charset = &apos;UTF-8&apos;;</div><div class=\"line\">        (document.getElementsByTagName(&apos;head&apos;)[0] </div><div class=\"line\">         || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</div><div class=\"line\">      &#125;)();</div><div class=\"line\">      &lt;/script&gt;</div><div class=\"line\">    &lt;!-- 多说公共JS代码 end --&gt;</div><div class=\"line\">  &lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo -g #安装  </div><div class=\"line\">npm update hexo -g #升级  </div><div class=\"line\">hexo init #初始化</div></pre></td></tr></table></figure>\n<blockquote>\n<p>简写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</div><div class=\"line\">hexo p == hexo publish</div><div class=\"line\">hexo g == hexo generate#生成</div><div class=\"line\">hexo s == hexo server #启动服务预览</div><div class=\"line\">hexo d == hexo deploy#部署</div></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</div><div class=\"line\">hexo server -s #静态模式</div><div class=\"line\">hexo server -p 5000 #更改端口</div><div class=\"line\">hexo server -i 192.168.1.1 #自定义 IP</div><div class=\"line\"></div><div class=\"line\">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</div><div class=\"line\">hexo g #生成静态网页</div><div class=\"line\">hexo d #开始部署</div></pre></td></tr></table></figure>\n<blockquote>\n<p>监视文件变动</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate #使用 Hexo 生成静态文件快速而且简单</div><div class=\"line\">hexo generate --watch #监视文件变动</div></pre></td></tr></table></figure>\n<blockquote>\n<p>完成后部署</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">两个命令的作用是相同的</div><div class=\"line\">hexo generate --deploy</div><div class=\"line\">hexo deploy --generate</div></pre></td></tr></table></figure>\n<blockquote>\n<p>草稿</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo publish [layout] &lt;title&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>模版</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div><div class=\"line\">hexo generate #生成静态页面至public目录</div><div class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\">hexo deploy #将.deploy目录部署到GitHub</div><div class=\"line\"></div><div class=\"line\">hexo new [layout] &lt;title&gt;</div><div class=\"line\">hexo new photo &quot;My Gallery&quot;</div><div class=\"line\">hexo new &quot;Hello World&quot; --lang tw</div></pre></td></tr></table></figure>\n<blockquote>\n<p>推送到服务器上</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n #写文章</div><div class=\"line\">hexo g #生成</div><div class=\"line\">hexo d #部署 #可与hexo g合并为 hexo d -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>报错</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.找不到git部署</div><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\">解决方法</div><div class=\"line\"></div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"></div><div class=\"line\">2.部署类型设置git</div><div class=\"line\">hexo 3.0 部署类型不再是github，_config.yml 中修改</div><div class=\"line\"></div><div class=\"line\"> Deployment</div><div class=\"line\"> Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\"></div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@***.github.com:***/***.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"></div><div class=\"line\">3. xcodebuild</div><div class=\"line\">xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance</div><div class=\"line\"></div><div class=\"line\">npm install bcrypt</div><div class=\"line\"></div><div class=\"line\">4. RSS不显示</div><div class=\"line\">安装RSS插件</div><div class=\"line\"></div><div class=\"line\">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>\n<blockquote>\n<p>开启RSS功能编辑hexo/_config.yml，添加如下代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rss: /atom.xml #rss地址  默认即可</div></pre></td></tr></table></figure>\n<blockquote>\n<p>开启评论</p>\n</blockquote>\n<ul>\n<li>1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</li>\n<li>2.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</li>\n<li>3.复制到 themes\\landscape\\layout_partial\\article.ejs</li>\n<li>4.把下面这段代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">&lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">&lt;div id=&quot;disqus_thread&quot;&gt;</div><div class=\"line\">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">  &lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">    &lt;!-- 多说评论框 start --&gt;</div><div class=\"line\">    &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;</div><div class=\"line\">    &lt;!-- 多说评论框 end --&gt;</div><div class=\"line\">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</div><div class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;;</div><div class=\"line\">      (function() &#123;</div><div class=\"line\">        var ds = document.createElement(&apos;script&apos;);</div><div class=\"line\">        ds.type = &apos;text/javascript&apos;;ds.async = true;</div><div class=\"line\">        ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;</div><div class=\"line\">        ds.charset = &apos;UTF-8&apos;;</div><div class=\"line\">        (document.getElementsByTagName(&apos;head&apos;)[0] </div><div class=\"line\">         || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</div><div class=\"line\">      &#125;)();</div><div class=\"line\">      &lt;/script&gt;</div><div class=\"line\">    &lt;!-- 多说公共JS代码 end --&gt;</div><div class=\"line\">  &lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>"},{"title":"精品文献合集","date":"2017-09-28T09:38:48.000Z","_content":"> 掘金翻译计划 Android\n\n- [[译] Activity 的正确打开方式 (Liz 翻译)](https://juejin.im/entry/57b9bfc3c4c9710061481310?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 如何创建高度模块化的 Android 应用 (DeadLion 翻译)](https://gold.xitu.io/entry/57b12cf4165abd00542a3ee1?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 使用强大的 Mockito 测试框架来测试你的代码 (edvardhua 翻译)](https://gold.xitu.io/entry/578f11aec4c971005e0caf82?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] Android 中美腻的下划线 (jamweak 翻译)](http://gold.xitu.io/entry/578705faa34131005b46e9c2?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [所有 Android 译文>>](https://github.com/xitu/gold-miner/blob/master/android.md)\n\n> 掘金翻译计划 iOS\n\n- [[译] 实现二叉树以及二叉树遍历数据结构 (cbangchen 翻译)](http://gold.xitu.io/entry/57cd6b028ac24700645a789c?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 关于 Swift，我不喜欢的几点 (cbangchen 翻译)](http://gold.xitu.io/entry/57cd6863128fe100697f1fed?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] iOS APP 中的不可变模型以及一致性数据 (Kulbear 翻译)](http://gold.xitu.io/entry/57caeb8a79bc440063fb7ef0?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 「最简单」的 Core Data 上手指南 (Zheaoli 翻译)](http://gold.xitu.io/entry/57c8f62f67f3560057aea07f?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [所有 iOS 译文>>](https://github.com/xitu/gold-miner/blob/master/ios.md)\n","source":"_posts/精品文献合集.md","raw":"---\ntitle: 精品文献合集\ndate: 2017-09-28 17:38:48\ntags: [iOS,Android,Python]\n---\n> 掘金翻译计划 Android\n\n- [[译] Activity 的正确打开方式 (Liz 翻译)](https://juejin.im/entry/57b9bfc3c4c9710061481310?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 如何创建高度模块化的 Android 应用 (DeadLion 翻译)](https://gold.xitu.io/entry/57b12cf4165abd00542a3ee1?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 使用强大的 Mockito 测试框架来测试你的代码 (edvardhua 翻译)](https://gold.xitu.io/entry/578f11aec4c971005e0caf82?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] Android 中美腻的下划线 (jamweak 翻译)](http://gold.xitu.io/entry/578705faa34131005b46e9c2?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [所有 Android 译文>>](https://github.com/xitu/gold-miner/blob/master/android.md)\n\n> 掘金翻译计划 iOS\n\n- [[译] 实现二叉树以及二叉树遍历数据结构 (cbangchen 翻译)](http://gold.xitu.io/entry/57cd6b028ac24700645a789c?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 关于 Swift，我不喜欢的几点 (cbangchen 翻译)](http://gold.xitu.io/entry/57cd6863128fe100697f1fed?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] iOS APP 中的不可变模型以及一致性数据 (Kulbear 翻译)](http://gold.xitu.io/entry/57caeb8a79bc440063fb7ef0?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [[译] 「最简单」的 Core Data 上手指南 (Zheaoli 翻译)](http://gold.xitu.io/entry/57c8f62f67f3560057aea07f?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n- [所有 iOS 译文>>](https://github.com/xitu/gold-miner/blob/master/ios.md)\n","slug":"精品文献合集","published":1,"updated":"2017-09-29T07:09:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj85ju40v00035iute9ph4bqy","content":"<blockquote>\n<p>掘金翻译计划 Android</p>\n</blockquote>\n<ul>\n<li><a href=\"https://juejin.im/entry/57b9bfc3c4c9710061481310?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] Activity 的正确打开方式 (Liz 翻译)</a></li>\n<li><a href=\"https://gold.xitu.io/entry/57b12cf4165abd00542a3ee1?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 如何创建高度模块化的 Android 应用 (DeadLion 翻译)</a></li>\n<li><a href=\"https://gold.xitu.io/entry/578f11aec4c971005e0caf82?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 使用强大的 Mockito 测试框架来测试你的代码 (edvardhua 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/578705faa34131005b46e9c2?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] Android 中美腻的下划线 (jamweak 翻译)</a></li>\n<li><a href=\"https://github.com/xitu/gold-miner/blob/master/android.md\" target=\"_blank\" rel=\"external\">所有 Android 译文&gt;&gt;</a></li>\n</ul>\n<blockquote>\n<p>掘金翻译计划 iOS</p>\n</blockquote>\n<ul>\n<li><a href=\"http://gold.xitu.io/entry/57cd6b028ac24700645a789c?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 实现二叉树以及二叉树遍历数据结构 (cbangchen 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57cd6863128fe100697f1fed?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 关于 Swift，我不喜欢的几点 (cbangchen 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57caeb8a79bc440063fb7ef0?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] iOS APP 中的不可变模型以及一致性数据 (Kulbear 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57c8f62f67f3560057aea07f?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 「最简单」的 Core Data 上手指南 (Zheaoli 翻译)</a></li>\n<li><a href=\"https://github.com/xitu/gold-miner/blob/master/ios.md\" target=\"_blank\" rel=\"external\">所有 iOS 译文&gt;&gt;</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>掘金翻译计划 Android</p>\n</blockquote>\n<ul>\n<li><a href=\"https://juejin.im/entry/57b9bfc3c4c9710061481310?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] Activity 的正确打开方式 (Liz 翻译)</a></li>\n<li><a href=\"https://gold.xitu.io/entry/57b12cf4165abd00542a3ee1?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 如何创建高度模块化的 Android 应用 (DeadLion 翻译)</a></li>\n<li><a href=\"https://gold.xitu.io/entry/578f11aec4c971005e0caf82?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 使用强大的 Mockito 测试框架来测试你的代码 (edvardhua 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/578705faa34131005b46e9c2?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] Android 中美腻的下划线 (jamweak 翻译)</a></li>\n<li><a href=\"https://github.com/xitu/gold-miner/blob/master/android.md\" target=\"_blank\" rel=\"external\">所有 Android 译文&gt;&gt;</a></li>\n</ul>\n<blockquote>\n<p>掘金翻译计划 iOS</p>\n</blockquote>\n<ul>\n<li><a href=\"http://gold.xitu.io/entry/57cd6b028ac24700645a789c?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 实现二叉树以及二叉树遍历数据结构 (cbangchen 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57cd6863128fe100697f1fed?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 关于 Swift，我不喜欢的几点 (cbangchen 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57caeb8a79bc440063fb7ef0?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] iOS APP 中的不可变模型以及一致性数据 (Kulbear 翻译)</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57c8f62f67f3560057aea07f?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github\" target=\"_blank\" rel=\"external\">[译] 「最简单」的 Core Data 上手指南 (Zheaoli 翻译)</a></li>\n<li><a href=\"https://github.com/xitu/gold-miner/blob/master/ios.md\" target=\"_blank\" rel=\"external\">所有 iOS 译文&gt;&gt;</a></li>\n</ul>\n"},{"title":"注册、登录和token的安全之道","date":"2017-09-28T09:08:20.000Z","_content":"> 注册、登录和 token 的安全之道\n\n最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。<!--more-->\n\n> 出于安全的考虑，首先定下三项原则：\n\n> 在传输中，不允许明文传输用户隐私数据；\n> 在本地，不允许明文保存用户隐私数据；\n> 在服务器，不允许明文保存用户隐私数据；\n在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。\n\n本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。\n\n使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。\n上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？\n\n> 加密\n\n将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。\n\nBase64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。\n\nBase64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 +/= 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 %XX 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。\n\n因此，Base64 只是一种编码方式，而不是加密方式。\n\n好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？\n\n> * 注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；\n> * 登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；\n> * token：确保用户在登录中；\n\n我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：\n\n服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；\n服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；\n登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；\n服务器定期清除 token；\n客户端-注册模块：向服务器注册接口发送账号和密码；\n客户端-登录模块：向服务器登录接口发送账号和密码；\n登录成功后，保存 token 到本地；\n退出登录后，清除 token；\n发送的账号和密码需要加密；\n数据库中需要保存的是加密后的账号和密码；\n请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；\n上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：\n\n```obj\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo return_value(10001, false);\n}\nelse {\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n    if ($result) {\n        echo return_value(0, true);\n    }\n    else {\n        echo return_value(20001, false);\n    }\n}\n```\n\n现在是服务器登录接口做的事情：\n\n```obj\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*是否命中用户名和密码*/\n$should_login = $db->should_login($account, $password);\n\nif ($should_login) {\n    /*更新 token*/\n    $token = $db->insert_token($account);\n    if ($token == '') {\n        echo response(40001, false);\n    }\n    else {\n        $data = ['token' => $token];\n        echo response(0, $data);\n    }\n}\nelse {\n    echo response(30001, false);\n}\n\n```\n剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。\n\n比如我们使用 md5 加密一个密码 123456，对应的 md5 是 e10adc3949ba59abbe56e057f20f883e，找到一个 md5 解密的网站，比如 cmd5.com/，很容易就被破解了密码…\n\n> 加盐\n\n工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：\n\n// 伪代码\n\n```\nsalt = '#^&%**(^&(&*)_)_(*&^&#$%GVHKBJ(*^&*%^%&^&'\npassword = '123456'\npost_body = salt + password\nprint post_body.md5()\n// ffb34d898f6573a1cf14fdc34d3343c0\n```\n现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。\n\n> 有泄露的可能\n\n现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 salt 这个字符串，那么加盐的做法也就形同虚设了。\n\n反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App 来说，仅仅加盐还是不够的。\n\n比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。\n\n> 依赖性太强\n\n盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。\n\n> HMAC\n\n目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。\n\n这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。\n\n但是还有一个问题，前面我们讲到，盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢？\n\n那就是，在用户注册时就生成和获取这个秘钥，以代码示例：\n\n现在我们发送一个请求：\n\nGET http://localhost:8888/capsule/register.php?account=joy&password=789\n服务器收到请求后，做了下面的事情：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n        $data = ['salt'=>$salt];\n        echo response(0, $data);\n        //echo response(0, true);\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n\n```\n服务器现在保存的是：\n\naccount: joy\npassword: 05575c24576\n客户端拿到的结果是：\n\n{\n  \"rc\": 0,\n  \"data\": {\n    \"salt\": \"5633905fdc65b6c57be8698b1f0e884948c05d7f\"\n  },\n  \"errorInfo\": \"\"\n}\n那么客户端接下来应该做什么呢？把 salt 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 password: 05575c24576 校验了，发起登录请求：\n\nGET http://localhost:8888/capsule/login.php?account=joy&password=789 \n// fail\nGET http://localhost:8888/capsule/login.php?account=joy&password=05575c24576 \n// success\n现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是有正确的密码，也无法登陆了吗？\n\n针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。\n\n// 伪代码\n\n```\nfunc login(account, password) {\n    //如果有盐\n    if let salt = getSalt() {\n        //将密码进行 hmac，请求登陆接口\n        network.login(account, password.hmac(salt))\n    }\n    else {\n        //请求 getSalt 接口，请求参数为账户+应用标识\n        network.getSalt(account + bundleId, { salt in\n            //将盐保存在本地，再次调用自身。\n            savaSalt(salt)\n            login(account, password)\n        })\n    }\n}\n\n```\n那么可想而知，我们的注册接口现在也需要新加一个 bundleId 的请求参数，然后用 account + bundleId 作为 key，来保存 salt：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n\n        /*检查秘钥是否保存成功*/\n        $save_salt = $db->save_salt($salt, $account, $bundle_id);\n\n        if ($save_salt) {\n            $data = ['salt'=>$salt];\n            echo response(0, $data);\n        }\n        else {\n            echo response(20001, false);\n        }\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n\n```\n\n同时我们需要创建一个获取 salt 的接口：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*获取秘钥*/\n$salt = $db->get_salt($account, $bundle_id);\n\nif ($salt == '') {\n    echo response(40001, false);\n}\nelse {\n    $data = ['salt'=>$salt];\n    echo response(0, $data);\n}\n\n```\n写到这里，就可以给大家介绍一个比较好玩的东西了。\n\n> 设备锁\n\n一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？\n\n就是用户开启设备锁之后，如果设备中没有 salt，那么就不再请求 getSalt 接口，而是转为其他验证方式，通过之后，才可以请求 getSalt。\n\n> 提升单个用户的安全性\n\n现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 salt 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？\n\n注册时返回的 salt 被抓包时有可能会泄露；\n更换设备后，获取的 salt 被抓包时有可能会泄露；\n保存在本地的 salt ，有可能通过文件路径获取到；\n抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；\n\n怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。\n\n我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。\n\n同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。\n\n所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。\n\n> HMAC+时间\n\n这个动态的种子是如何使用的呢？\n\n客户端发送注册请求，服务器返回 salt，保存 hmac 后的密码；\n客户端保存 salt；\n客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；\n服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；\n客户端代码：\n\n```\n// 秘钥\nconst salt = ''\n// 当前时间，精确到分钟\nconst currentTime = '201709171204'\n// 用户输入的密码\nlet password = '123456'\n// (hmac+currentTime).md5\npassword = (password.hmac(salt) + currentTime).md5()\nnetwork('login', {method: 'GET', params: {password:password}})\n```\n服务器代码：\n\n```\nfunction should_login($account, $password)\n{\n    $account = mysqli_real_escape_string($this->connection ,$account);\n    $password = mysqli_real_escape_string($this->connection, $password);\n    $user = $this->get_user($account);\n    if ($user == null) {\n        return false;\n    }\n    $password_local = $user['password'];\n    if ($password_local == '') {\n        return false;\n    }\n    $password_local = md5($password_local.current_time());\n    if ($password_local == $password) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n```\n\n但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 201709171204，服务器响应时却已经到了 201709171205 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。\n\n聪明的你应该可以想到，这也就是验证码 5 分钟内有效期的实现。\n\n现在这个 App，就算注册时拿到了 salt，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。","source":"_posts/注册、登录和token的安全之道.md","raw":"---\ntitle: 注册、登录和token的安全之道\ndate: 2017-09-28 17:08:20\ntags: [PHP,Interface]\ncategories: PHP\n---\n> 注册、登录和 token 的安全之道\n\n最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。<!--more-->\n\n> 出于安全的考虑，首先定下三项原则：\n\n> 在传输中，不允许明文传输用户隐私数据；\n> 在本地，不允许明文保存用户隐私数据；\n> 在服务器，不允许明文保存用户隐私数据；\n在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。\n\n本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。\n\n使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。\n上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？\n\n> 加密\n\n将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。\n\nBase64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。\n\nBase64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 +/= 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 %XX 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。\n\n因此，Base64 只是一种编码方式，而不是加密方式。\n\n好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？\n\n> * 注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；\n> * 登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；\n> * token：确保用户在登录中；\n\n我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：\n\n服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；\n服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；\n登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；\n服务器定期清除 token；\n客户端-注册模块：向服务器注册接口发送账号和密码；\n客户端-登录模块：向服务器登录接口发送账号和密码；\n登录成功后，保存 token 到本地；\n退出登录后，清除 token；\n发送的账号和密码需要加密；\n数据库中需要保存的是加密后的账号和密码；\n请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；\n上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：\n\n```obj\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo return_value(10001, false);\n}\nelse {\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n    if ($result) {\n        echo return_value(0, true);\n    }\n    else {\n        echo return_value(20001, false);\n    }\n}\n```\n\n现在是服务器登录接口做的事情：\n\n```obj\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*是否命中用户名和密码*/\n$should_login = $db->should_login($account, $password);\n\nif ($should_login) {\n    /*更新 token*/\n    $token = $db->insert_token($account);\n    if ($token == '') {\n        echo response(40001, false);\n    }\n    else {\n        $data = ['token' => $token];\n        echo response(0, $data);\n    }\n}\nelse {\n    echo response(30001, false);\n}\n\n```\n剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。\n\n比如我们使用 md5 加密一个密码 123456，对应的 md5 是 e10adc3949ba59abbe56e057f20f883e，找到一个 md5 解密的网站，比如 cmd5.com/，很容易就被破解了密码…\n\n> 加盐\n\n工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：\n\n// 伪代码\n\n```\nsalt = '#^&%**(^&(&*)_)_(*&^&#$%GVHKBJ(*^&*%^%&^&'\npassword = '123456'\npost_body = salt + password\nprint post_body.md5()\n// ffb34d898f6573a1cf14fdc34d3343c0\n```\n现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。\n\n> 有泄露的可能\n\n现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 salt 这个字符串，那么加盐的做法也就形同虚设了。\n\n反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App 来说，仅仅加盐还是不够的。\n\n比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。\n\n> 依赖性太强\n\n盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。\n\n> HMAC\n\n目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。\n\n这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。\n\n但是还有一个问题，前面我们讲到，盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢？\n\n那就是，在用户注册时就生成和获取这个秘钥，以代码示例：\n\n现在我们发送一个请求：\n\nGET http://localhost:8888/capsule/register.php?account=joy&password=789\n服务器收到请求后，做了下面的事情：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n        $data = ['salt'=>$salt];\n        echo response(0, $data);\n        //echo response(0, true);\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n\n```\n服务器现在保存的是：\n\naccount: joy\npassword: 05575c24576\n客户端拿到的结果是：\n\n{\n  \"rc\": 0,\n  \"data\": {\n    \"salt\": \"5633905fdc65b6c57be8698b1f0e884948c05d7f\"\n  },\n  \"errorInfo\": \"\"\n}\n那么客户端接下来应该做什么呢？把 salt 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 password: 05575c24576 校验了，发起登录请求：\n\nGET http://localhost:8888/capsule/login.php?account=joy&password=789 \n// fail\nGET http://localhost:8888/capsule/login.php?account=joy&password=05575c24576 \n// success\n现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是有正确的密码，也无法登陆了吗？\n\n针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。\n\n// 伪代码\n\n```\nfunc login(account, password) {\n    //如果有盐\n    if let salt = getSalt() {\n        //将密码进行 hmac，请求登陆接口\n        network.login(account, password.hmac(salt))\n    }\n    else {\n        //请求 getSalt 接口，请求参数为账户+应用标识\n        network.getSalt(account + bundleId, { salt in\n            //将盐保存在本地，再次调用自身。\n            savaSalt(salt)\n            login(account, password)\n        })\n    }\n}\n\n```\n那么可想而知，我们的注册接口现在也需要新加一个 bundleId 的请求参数，然后用 account + bundleId 作为 key，来保存 salt：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n\n        /*检查秘钥是否保存成功*/\n        $save_salt = $db->save_salt($salt, $account, $bundle_id);\n\n        if ($save_salt) {\n            $data = ['salt'=>$salt];\n            echo response(0, $data);\n        }\n        else {\n            echo response(20001, false);\n        }\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n\n```\n\n同时我们需要创建一个获取 salt 的接口：\n\n```\n/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*获取秘钥*/\n$salt = $db->get_salt($account, $bundle_id);\n\nif ($salt == '') {\n    echo response(40001, false);\n}\nelse {\n    $data = ['salt'=>$salt];\n    echo response(0, $data);\n}\n\n```\n写到这里，就可以给大家介绍一个比较好玩的东西了。\n\n> 设备锁\n\n一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？\n\n就是用户开启设备锁之后，如果设备中没有 salt，那么就不再请求 getSalt 接口，而是转为其他验证方式，通过之后，才可以请求 getSalt。\n\n> 提升单个用户的安全性\n\n现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 salt 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？\n\n注册时返回的 salt 被抓包时有可能会泄露；\n更换设备后，获取的 salt 被抓包时有可能会泄露；\n保存在本地的 salt ，有可能通过文件路径获取到；\n抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；\n\n怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。\n\n我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。\n\n同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。\n\n所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。\n\n> HMAC+时间\n\n这个动态的种子是如何使用的呢？\n\n客户端发送注册请求，服务器返回 salt，保存 hmac 后的密码；\n客户端保存 salt；\n客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；\n服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；\n客户端代码：\n\n```\n// 秘钥\nconst salt = ''\n// 当前时间，精确到分钟\nconst currentTime = '201709171204'\n// 用户输入的密码\nlet password = '123456'\n// (hmac+currentTime).md5\npassword = (password.hmac(salt) + currentTime).md5()\nnetwork('login', {method: 'GET', params: {password:password}})\n```\n服务器代码：\n\n```\nfunction should_login($account, $password)\n{\n    $account = mysqli_real_escape_string($this->connection ,$account);\n    $password = mysqli_real_escape_string($this->connection, $password);\n    $user = $this->get_user($account);\n    if ($user == null) {\n        return false;\n    }\n    $password_local = $user['password'];\n    if ($password_local == '') {\n        return false;\n    }\n    $password_local = md5($password_local.current_time());\n    if ($password_local == $password) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n```\n\n但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 201709171204，服务器响应时却已经到了 201709171205 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。\n\n聪明的你应该可以想到，这也就是验证码 5 分钟内有效期的实现。\n\n现在这个 App，就算注册时拿到了 salt，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。","slug":"注册、登录和token的安全之道","published":1,"updated":"2017-09-29T07:09:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj85ju417000c5iut188bzddi","content":"<blockquote>\n<p>注册、登录和 token 的安全之道</p>\n</blockquote>\n<p>最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。<a id=\"more\"></a></p>\n<blockquote>\n<p>出于安全的考虑，首先定下三项原则：</p>\n<p>在传输中，不允许明文传输用户隐私数据；<br>在本地，不允许明文保存用户隐私数据；<br>在服务器，不允许明文保存用户隐私数据；<br>在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。</p>\n</blockquote>\n<p>本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。</p>\n<p>使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。<br>上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？</p>\n<blockquote>\n<p>加密</p>\n</blockquote>\n<p>将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。</p>\n<p>Base64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。</p>\n<p>Base64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 +/= 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 %XX 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。</p>\n<p>因此，Base64 只是一种编码方式，而不是加密方式。</p>\n<p>好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？</p>\n<blockquote>\n<ul>\n<li>注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；</li>\n<li>登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；</li>\n<li>token：确保用户在登录中；</li>\n</ul>\n</blockquote>\n<p>我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：</p>\n<p>服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；<br>服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；<br>登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；<br>服务器定期清除 token；<br>客户端-注册模块：向服务器注册接口发送账号和密码；<br>客户端-登录模块：向服务器登录接口发送账号和密码；<br>登录成功后，保存 token 到本地；<br>退出登录后，清除 token；<br>发送的账号和密码需要加密；<br>数据库中需要保存的是加密后的账号和密码；<br>请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；<br>上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo return_value(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\">        echo return_value(0, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo return_value(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在是服务器登录接口做的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*是否命中用户名和密码*/</div><div class=\"line\">$should_login = $db-&gt;should_login($account, $password);</div><div class=\"line\"></div><div class=\"line\">if ($should_login) &#123;</div><div class=\"line\">    /*更新 token*/</div><div class=\"line\">    $token = $db-&gt;insert_token($account);</div><div class=\"line\">    if ($token == &apos;&apos;) &#123;</div><div class=\"line\">        echo response(40001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        $data = [&apos;token&apos; =&gt; $token];</div><div class=\"line\">        echo response(0, $data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    echo response(30001, false);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。</p>\n<p>比如我们使用 md5 加密一个密码 123456，对应的 md5 是 e10adc3949ba59abbe56e057f20f883e，找到一个 md5 解密的网站，比如 cmd5.com/，很容易就被破解了密码…</p>\n<blockquote>\n<p>加盐</p>\n</blockquote>\n<p>工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：</p>\n<p>// 伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">salt = &apos;#^&amp;%**(^&amp;(&amp;*)_)_(*&amp;^&amp;#$%GVHKBJ(*^&amp;*%^%&amp;^&amp;&apos;</div><div class=\"line\">password = &apos;123456&apos;</div><div class=\"line\">post_body = salt + password</div><div class=\"line\">print post_body.md5()</div><div class=\"line\">// ffb34d898f6573a1cf14fdc34d3343c0</div></pre></td></tr></table></figure>\n<p>现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。</p>\n<blockquote>\n<p>有泄露的可能</p>\n</blockquote>\n<p>现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 salt 这个字符串，那么加盐的做法也就形同虚设了。</p>\n<p>反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App 来说，仅仅加盐还是不够的。</p>\n<p>比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。</p>\n<blockquote>\n<p>依赖性太强</p>\n</blockquote>\n<p>盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。</p>\n<blockquote>\n<p>HMAC</p>\n</blockquote>\n<p>目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。</p>\n<p>这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。</p>\n<p>但是还有一个问题，前面我们讲到，盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢？</p>\n<p>那就是，在用户注册时就生成和获取这个秘钥，以代码示例：</p>\n<p>现在我们发送一个请求：</p>\n<p>GET <a href=\"http://localhost:8888/capsule/register.php?account=joy&amp;password=789\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/register.php?account=joy&amp;password=789</a><br>服务器收到请求后，做了下面的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];  //123456</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*制作一个随机的盐*/</div><div class=\"line\">$salt = salt();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo response(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\"></div><div class=\"line\">    /*将密码进行 hmac 加密*/</div><div class=\"line\">    $password = str_hmac($password,  $salt);</div><div class=\"line\"></div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\"></div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\">        $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">        echo response(0, $data);</div><div class=\"line\">        //echo response(0, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo response(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>服务器现在保存的是：</p>\n<p>account: joy<br>password: 05575c24576<br>客户端拿到的结果是：</p>\n<p>{<br>  “rc”: 0,<br>  “data”: {<br>    “salt”: “5633905fdc65b6c57be8698b1f0e884948c05d7f”<br>  },<br>  “errorInfo”: “”<br>}<br>那么客户端接下来应该做什么呢？把 salt 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 password: 05575c24576 校验了，发起登录请求：</p>\n<p>GET <a href=\"http://localhost:8888/capsule/login.php?account=joy&amp;password=789\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/login.php?account=joy&amp;password=789</a><br>// fail<br>GET <a href=\"http://localhost:8888/capsule/login.php?account=joy&amp;password=05575c24576\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/login.php?account=joy&amp;password=05575c24576</a><br>// success<br>现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是有正确的密码，也无法登陆了吗？</p>\n<p>针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。</p>\n<p>// 伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func login(account, password) &#123;</div><div class=\"line\">    //如果有盐</div><div class=\"line\">    if let salt = getSalt() &#123;</div><div class=\"line\">        //将密码进行 hmac，请求登陆接口</div><div class=\"line\">        network.login(account, password.hmac(salt))</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        //请求 getSalt 接口，请求参数为账户+应用标识</div><div class=\"line\">        network.getSalt(account + bundleId, &#123; salt in</div><div class=\"line\">            //将盐保存在本地，再次调用自身。</div><div class=\"line\">            savaSalt(salt)</div><div class=\"line\">            login(account, password)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么可想而知，我们的注册接口现在也需要新加一个 bundleId 的请求参数，然后用 account + bundleId 作为 key，来保存 salt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];  //123456</div><div class=\"line\">$bundle_id = $_GET[&apos;bundleId&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*制作一个随机的盐*/</div><div class=\"line\">$salt = salt();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo response(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    /*将密码进行 hmac 加密*/</div><div class=\"line\">    $password = str_hmac($password,  $salt);</div><div class=\"line\"></div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\"></div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\"></div><div class=\"line\">        /*检查秘钥是否保存成功*/</div><div class=\"line\">        $save_salt = $db-&gt;save_salt($salt, $account, $bundle_id);</div><div class=\"line\"></div><div class=\"line\">        if ($save_salt) &#123;</div><div class=\"line\">            $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">            echo response(0, $data);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            echo response(20001, false);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo response(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同时我们需要创建一个获取 salt 的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$bundle_id = $_GET[&apos;bundleId&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*获取秘钥*/</div><div class=\"line\">$salt = $db-&gt;get_salt($account, $bundle_id);</div><div class=\"line\"></div><div class=\"line\">if ($salt == &apos;&apos;) &#123;</div><div class=\"line\">    echo response(40001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">    echo response(0, $data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>写到这里，就可以给大家介绍一个比较好玩的东西了。</p>\n<blockquote>\n<p>设备锁</p>\n</blockquote>\n<p>一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？</p>\n<p>就是用户开启设备锁之后，如果设备中没有 salt，那么就不再请求 getSalt 接口，而是转为其他验证方式，通过之后，才可以请求 getSalt。</p>\n<blockquote>\n<p>提升单个用户的安全性</p>\n</blockquote>\n<p>现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 salt 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？</p>\n<p>注册时返回的 salt 被抓包时有可能会泄露；<br>更换设备后，获取的 salt 被抓包时有可能会泄露；<br>保存在本地的 salt ，有可能通过文件路径获取到；<br>抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；</p>\n<p>怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。</p>\n<p>我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。</p>\n<p>同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。</p>\n<p>所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。</p>\n<blockquote>\n<p>HMAC+时间</p>\n</blockquote>\n<p>这个动态的种子是如何使用的呢？</p>\n<p>客户端发送注册请求，服务器返回 salt，保存 hmac 后的密码；<br>客户端保存 salt；<br>客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；<br>服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；<br>客户端代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 秘钥</div><div class=\"line\">const salt = &apos;&apos;</div><div class=\"line\">// 当前时间，精确到分钟</div><div class=\"line\">const currentTime = &apos;201709171204&apos;</div><div class=\"line\">// 用户输入的密码</div><div class=\"line\">let password = &apos;123456&apos;</div><div class=\"line\">// (hmac+currentTime).md5</div><div class=\"line\">password = (password.hmac(salt) + currentTime).md5()</div><div class=\"line\">network(&apos;login&apos;, &#123;method: &apos;GET&apos;, params: &#123;password:password&#125;&#125;)</div></pre></td></tr></table></figure>\n<p>服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function should_login($account, $password)</div><div class=\"line\">&#123;</div><div class=\"line\">    $account = mysqli_real_escape_string($this-&gt;connection ,$account);</div><div class=\"line\">    $password = mysqli_real_escape_string($this-&gt;connection, $password);</div><div class=\"line\">    $user = $this-&gt;get_user($account);</div><div class=\"line\">    if ($user == null) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    $password_local = $user[&apos;password&apos;];</div><div class=\"line\">    if ($password_local == &apos;&apos;) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    $password_local = md5($password_local.current_time());</div><div class=\"line\">    if ($password_local == $password) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 201709171204，服务器响应时却已经到了 201709171205 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。</p>\n<p>聪明的你应该可以想到，这也就是验证码 5 分钟内有效期的实现。</p>\n<p>现在这个 App，就算注册时拿到了 salt，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>注册、登录和 token 的安全之道</p>\n</blockquote>\n<p>最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。","more":"</p>\n<blockquote>\n<p>出于安全的考虑，首先定下三项原则：</p>\n<p>在传输中，不允许明文传输用户隐私数据；<br>在本地，不允许明文保存用户隐私数据；<br>在服务器，不允许明文保存用户隐私数据；<br>在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。</p>\n</blockquote>\n<p>本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。</p>\n<p>使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。<br>上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？</p>\n<blockquote>\n<p>加密</p>\n</blockquote>\n<p>将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。</p>\n<p>Base64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。</p>\n<p>Base64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 +/= 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 %XX 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。</p>\n<p>因此，Base64 只是一种编码方式，而不是加密方式。</p>\n<p>好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？</p>\n<blockquote>\n<ul>\n<li>注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；</li>\n<li>登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；</li>\n<li>token：确保用户在登录中；</li>\n</ul>\n</blockquote>\n<p>我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：</p>\n<p>服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；<br>服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；<br>登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；<br>服务器定期清除 token；<br>客户端-注册模块：向服务器注册接口发送账号和密码；<br>客户端-登录模块：向服务器登录接口发送账号和密码；<br>登录成功后，保存 token 到本地；<br>退出登录后，清除 token；<br>发送的账号和密码需要加密；<br>数据库中需要保存的是加密后的账号和密码；<br>请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；<br>上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo return_value(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\">        echo return_value(0, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo return_value(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在是服务器登录接口做的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*是否命中用户名和密码*/</div><div class=\"line\">$should_login = $db-&gt;should_login($account, $password);</div><div class=\"line\"></div><div class=\"line\">if ($should_login) &#123;</div><div class=\"line\">    /*更新 token*/</div><div class=\"line\">    $token = $db-&gt;insert_token($account);</div><div class=\"line\">    if ($token == &apos;&apos;) &#123;</div><div class=\"line\">        echo response(40001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        $data = [&apos;token&apos; =&gt; $token];</div><div class=\"line\">        echo response(0, $data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    echo response(30001, false);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。</p>\n<p>比如我们使用 md5 加密一个密码 123456，对应的 md5 是 e10adc3949ba59abbe56e057f20f883e，找到一个 md5 解密的网站，比如 cmd5.com/，很容易就被破解了密码…</p>\n<blockquote>\n<p>加盐</p>\n</blockquote>\n<p>工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：</p>\n<p>// 伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">salt = &apos;#^&amp;%**(^&amp;(&amp;*)_)_(*&amp;^&amp;#$%GVHKBJ(*^&amp;*%^%&amp;^&amp;&apos;</div><div class=\"line\">password = &apos;123456&apos;</div><div class=\"line\">post_body = salt + password</div><div class=\"line\">print post_body.md5()</div><div class=\"line\">// ffb34d898f6573a1cf14fdc34d3343c0</div></pre></td></tr></table></figure>\n<p>现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。</p>\n<blockquote>\n<p>有泄露的可能</p>\n</blockquote>\n<p>现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 salt 这个字符串，那么加盐的做法也就形同虚设了。</p>\n<p>反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App 来说，仅仅加盐还是不够的。</p>\n<p>比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。</p>\n<blockquote>\n<p>依赖性太强</p>\n</blockquote>\n<p>盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。</p>\n<blockquote>\n<p>HMAC</p>\n</blockquote>\n<p>目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。</p>\n<p>这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。</p>\n<p>但是还有一个问题，前面我们讲到，盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢？</p>\n<p>那就是，在用户注册时就生成和获取这个秘钥，以代码示例：</p>\n<p>现在我们发送一个请求：</p>\n<p>GET <a href=\"http://localhost:8888/capsule/register.php?account=joy&amp;password=789\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/register.php?account=joy&amp;password=789</a><br>服务器收到请求后，做了下面的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];  //123456</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*制作一个随机的盐*/</div><div class=\"line\">$salt = salt();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo response(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\"></div><div class=\"line\">    /*将密码进行 hmac 加密*/</div><div class=\"line\">    $password = str_hmac($password,  $salt);</div><div class=\"line\"></div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\"></div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\">        $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">        echo response(0, $data);</div><div class=\"line\">        //echo response(0, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo response(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>服务器现在保存的是：</p>\n<p>account: joy<br>password: 05575c24576<br>客户端拿到的结果是：</p>\n<p>{<br>  “rc”: 0,<br>  “data”: {<br>    “salt”: “5633905fdc65b6c57be8698b1f0e884948c05d7f”<br>  },<br>  “errorInfo”: “”<br>}<br>那么客户端接下来应该做什么呢？把 salt 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 password: 05575c24576 校验了，发起登录请求：</p>\n<p>GET <a href=\"http://localhost:8888/capsule/login.php?account=joy&amp;password=789\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/login.php?account=joy&amp;password=789</a><br>// fail<br>GET <a href=\"http://localhost:8888/capsule/login.php?account=joy&amp;password=05575c24576\" target=\"_blank\" rel=\"external\">http://localhost:8888/capsule/login.php?account=joy&amp;password=05575c24576</a><br>// success<br>现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是有正确的密码，也无法登陆了吗？</p>\n<p>针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。</p>\n<p>// 伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func login(account, password) &#123;</div><div class=\"line\">    //如果有盐</div><div class=\"line\">    if let salt = getSalt() &#123;</div><div class=\"line\">        //将密码进行 hmac，请求登陆接口</div><div class=\"line\">        network.login(account, password.hmac(salt))</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        //请求 getSalt 接口，请求参数为账户+应用标识</div><div class=\"line\">        network.getSalt(account + bundleId, &#123; salt in</div><div class=\"line\">            //将盐保存在本地，再次调用自身。</div><div class=\"line\">            savaSalt(salt)</div><div class=\"line\">            login(account, password)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么可想而知，我们的注册接口现在也需要新加一个 bundleId 的请求参数，然后用 account + bundleId 作为 key，来保存 salt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$password = $_GET[&apos;password&apos;];  //123456</div><div class=\"line\">$bundle_id = $_GET[&apos;bundleId&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*制作一个随机的盐*/</div><div class=\"line\">$salt = salt();</div><div class=\"line\"></div><div class=\"line\">/*检查用户名是否存在*/</div><div class=\"line\">$is_exist = $db-&gt;check_user_exist($account);</div><div class=\"line\"></div><div class=\"line\">if ($is_exist) &#123;</div><div class=\"line\">    echo response(10001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    /*将密码进行 hmac 加密*/</div><div class=\"line\">    $password = str_hmac($password,  $salt);</div><div class=\"line\"></div><div class=\"line\">    /*检查用户名是否添加成功*/</div><div class=\"line\">    $result = $db-&gt;add_user($account, $password);</div><div class=\"line\"></div><div class=\"line\">    if ($result) &#123;</div><div class=\"line\"></div><div class=\"line\">        /*检查秘钥是否保存成功*/</div><div class=\"line\">        $save_salt = $db-&gt;save_salt($salt, $account, $bundle_id);</div><div class=\"line\"></div><div class=\"line\">        if ($save_salt) &#123;</div><div class=\"line\">            $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">            echo response(0, $data);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            echo response(20001, false);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        echo response(20001, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同时我们需要创建一个获取 salt 的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*获取 get 请求传递的参数*/</div><div class=\"line\">$account = $_GET[&apos;account&apos;];</div><div class=\"line\">$bundle_id = $_GET[&apos;bundleId&apos;];</div><div class=\"line\"></div><div class=\"line\">/*创建数据连接*/</div><div class=\"line\">$db = new DataBase();</div><div class=\"line\"></div><div class=\"line\">/*获取秘钥*/</div><div class=\"line\">$salt = $db-&gt;get_salt($account, $bundle_id);</div><div class=\"line\"></div><div class=\"line\">if ($salt == &apos;&apos;) &#123;</div><div class=\"line\">    echo response(40001, false);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">    $data = [&apos;salt&apos;=&gt;$salt];</div><div class=\"line\">    echo response(0, $data);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>写到这里，就可以给大家介绍一个比较好玩的东西了。</p>\n<blockquote>\n<p>设备锁</p>\n</blockquote>\n<p>一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？</p>\n<p>就是用户开启设备锁之后，如果设备中没有 salt，那么就不再请求 getSalt 接口，而是转为其他验证方式，通过之后，才可以请求 getSalt。</p>\n<blockquote>\n<p>提升单个用户的安全性</p>\n</blockquote>\n<p>现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 salt 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？</p>\n<p>注册时返回的 salt 被抓包时有可能会泄露；<br>更换设备后，获取的 salt 被抓包时有可能会泄露；<br>保存在本地的 salt ，有可能通过文件路径获取到；<br>抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；</p>\n<p>怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。</p>\n<p>我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。</p>\n<p>同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。</p>\n<p>所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。</p>\n<blockquote>\n<p>HMAC+时间</p>\n</blockquote>\n<p>这个动态的种子是如何使用的呢？</p>\n<p>客户端发送注册请求，服务器返回 salt，保存 hmac 后的密码；<br>客户端保存 salt；<br>客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；<br>服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；<br>客户端代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 秘钥</div><div class=\"line\">const salt = &apos;&apos;</div><div class=\"line\">// 当前时间，精确到分钟</div><div class=\"line\">const currentTime = &apos;201709171204&apos;</div><div class=\"line\">// 用户输入的密码</div><div class=\"line\">let password = &apos;123456&apos;</div><div class=\"line\">// (hmac+currentTime).md5</div><div class=\"line\">password = (password.hmac(salt) + currentTime).md5()</div><div class=\"line\">network(&apos;login&apos;, &#123;method: &apos;GET&apos;, params: &#123;password:password&#125;&#125;)</div></pre></td></tr></table></figure>\n<p>服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function should_login($account, $password)</div><div class=\"line\">&#123;</div><div class=\"line\">    $account = mysqli_real_escape_string($this-&gt;connection ,$account);</div><div class=\"line\">    $password = mysqli_real_escape_string($this-&gt;connection, $password);</div><div class=\"line\">    $user = $this-&gt;get_user($account);</div><div class=\"line\">    if ($user == null) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    $password_local = $user[&apos;password&apos;];</div><div class=\"line\">    if ($password_local == &apos;&apos;) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    $password_local = md5($password_local.current_time());</div><div class=\"line\">    if ($password_local == $password) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 201709171204，服务器响应时却已经到了 201709171205 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。</p>\n<p>聪明的你应该可以想到，这也就是验证码 5 分钟内有效期的实现。</p>\n<p>现在这个 App，就算注册时拿到了 salt，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj85ju417000c5iut188bzddi","category_id":"cj85ju418000d5iutsnjao5sq","_id":"cj85ju41d000g5iutlyarjlkp"}],"PostTag":[{"post_id":"cj85ju40p00015iut34gkrn6l","tag_id":"cj85ju40x00045iutzh7jx3to","_id":"cj85ju41400065iut0wnhubtu"},{"post_id":"cj85ju40v00035iute9ph4bqy","tag_id":"cj85ju41300055iut5c5r0eyq","_id":"cj85ju41500095iutwz250uil"},{"post_id":"cj85ju40v00035iute9ph4bqy","tag_id":"cj85ju41500075iutr6t8p57g","_id":"cj85ju416000a5iutrr21zfhq"},{"post_id":"cj85ju40v00035iute9ph4bqy","tag_id":"cj85ju41500085iutxaylx54a","_id":"cj85ju416000b5iutf9ko0tdp"},{"post_id":"cj85ju417000c5iut188bzddi","tag_id":"cj85ju419000e5iutsz54waqk","_id":"cj85ju41e000h5iutrbxgvpfe"},{"post_id":"cj85ju417000c5iut188bzddi","tag_id":"cj85ju41a000f5iuti8ppg1fw","_id":"cj85ju41e000i5iutei08p68u"}],"Tag":[{"name":"hexo","_id":"cj85ju40x00045iutzh7jx3to"},{"name":"iOS","_id":"cj85ju41300055iut5c5r0eyq"},{"name":"Android","_id":"cj85ju41500075iutr6t8p57g"},{"name":"Python","_id":"cj85ju41500085iutxaylx54a"},{"name":"PHP","_id":"cj85ju419000e5iutsz54waqk"},{"name":"Interface","_id":"cj85ju41a000f5iuti8ppg1fw"}]}}